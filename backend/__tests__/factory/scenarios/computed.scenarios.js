/**
 * Computed Field Test Scenarios
 *
 * Pure functions testing auto-generated identifiers and computed fields.
 * These verify that entities with computed fields generate them correctly.
 *
 * PRINCIPLE: Computed fields (like work_order_number, invoice_number) should
 * be auto-generated on creation, not manually provided by the client.
 * 
 * DETECTION: Uses identifierPrefix + identityField from metadata
 * Applies to: work_order, invoice, contract (COMPUTED nameType entities)
 */

const { getCapabilities } = require('./scenario-helpers');

/**
 * Check if entity has auto-generated identifier (COMPUTED entities)
 * Detection: Has identifierPrefix AND identityField in metadata
 */
function hasAutoGeneratedIdentifier(meta) {
  return !!meta.identifierPrefix && !!meta.identityField;
}

/**
 * Scenario: Create generates auto-identifier following PREFIX-YYYY-NNNN format
 *
 * Preconditions: Entity has identifierPrefix + identityField (COMPUTED entity)
 * Tests: Created entity has properly formatted identifier
 */
function createGeneratesAutoIdentifier(meta, ctx) {
  if (!hasAutoGeneratedIdentifier(meta)) return;

  const caps = getCapabilities(meta);
  if (!caps.canCreate) return;

  const { entityName, tableName, identityField, identifierPrefix } = meta;

  ctx.it(`POST /api/${tableName} - auto-generates ${identityField}`, async () => {
    const payload = await ctx.factory.buildMinimalWithFKs(entityName);
    
    // Explicitly DO NOT include the computed field
    delete payload[identityField];
    
    const auth = await ctx.authHeader('admin');

    const response = await ctx.request
      .post(`/api/${tableName}`)
      .set(auth)
      .send(payload);

    ctx.expect(response.status).toBe(201);
    
    const data = response.body.data || response.body;
    
    // The computed field should be present and non-null
    ctx.expect(data[identityField]).toBeDefined();
    ctx.expect(data[identityField]).not.toBeNull();
    
    // Should match format: PREFIX-YYYY-NNNN
    const expectedPattern = new RegExp(`^${identifierPrefix}-\\d{4}-\\d{4,}$`);
    ctx.expect(data[identityField]).toMatch(expectedPattern);
  });
}

/**
 * Scenario: Sequential creation increments identifier
 *
 * Preconditions: Entity has auto-generated identifier
 * Tests: Creating two entities produces sequential identifiers
 */
function sequentialCreationIncrements(meta, ctx) {
  if (!hasAutoGeneratedIdentifier(meta)) return;

  const caps = getCapabilities(meta);
  if (!caps.canCreate) return;

  const { entityName, tableName, identityField } = meta;

  ctx.it(`POST /api/${tableName} - sequential creates increment ${identityField}`, async () => {
    const auth = await ctx.authHeader('admin');

    // Create first entity
    const payload1 = await ctx.factory.buildMinimalWithFKs(entityName);
    delete payload1[identityField];
    const response1 = await ctx.request
      .post(`/api/${tableName}`)
      .set(auth)
      .send(payload1);

    ctx.expect(response1.status).toBe(201);
    const data1 = response1.body.data || response1.body;
    const value1 = data1[identityField];

    // Create second entity
    const payload2 = await ctx.factory.buildMinimalWithFKs(entityName);
    delete payload2[identityField];
    const response2 = await ctx.request
      .post(`/api/${tableName}`)
      .set(auth)
      .send(payload2);

    ctx.expect(response2.status).toBe(201);
    const data2 = response2.body.data || response2.body;
    const value2 = data2[identityField];

    // Values should be different
    ctx.expect(value2).not.toBe(value1);

    // Extract sequence portion (last part after final dash)
    const seq1 = parseInt(value1.split('-').pop(), 10);
    const seq2 = parseInt(value2.split('-').pop(), 10);
    ctx.expect(seq2).toBeGreaterThan(seq1);
  });
}

/**
 * Scenario: Client cannot override computed identifier field
 *
 * Preconditions: Entity has auto-generated identifier
 * Tests: Providing computed field in payload is ignored
 */
function clientCannotOverrideIdentifier(meta, ctx) {
  if (!hasAutoGeneratedIdentifier(meta)) return;

  const caps = getCapabilities(meta);
  if (!caps.canCreate) return;

  const { entityName, tableName, identityField, identifierPrefix } = meta;

  ctx.it(`POST /api/${tableName} - ignores client-provided ${identityField}`, async () => {
    const payload = await ctx.factory.buildMinimalWithFKs(entityName);
    
    // Try to override with a specific value
    payload[identityField] = 'HACKED-9999-9999';
    
    const auth = await ctx.authHeader('admin');

    const response = await ctx.request
      .post(`/api/${tableName}`)
      .set(auth)
      .send(payload);

    ctx.expect(response.status).toBe(201);
    
    const data = response.body.data || response.body;
    
    // Server should have ignored the client value and generated its own
    ctx.expect(data[identityField]).not.toBe('HACKED-9999-9999');
    
    // Should still match the proper format
    const expectedPattern = new RegExp(`^${identifierPrefix}-\\d{4}-\\d{4,}$`);
    ctx.expect(data[identityField]).toMatch(expectedPattern);
  });
}

/**
 * Scenario: Identifier field is immutable after creation
 *
 * Preconditions: Entity has auto-generated identifier AND identityField in immutableFields
 * Tests: PATCH with identifier field is rejected or ignored
 */
function identifierIsImmutable(meta, ctx) {
  if (!hasAutoGeneratedIdentifier(meta)) return;
  
  // Check if identityField is in immutableFields
  const isImmutable = meta.immutableFields?.includes(meta.identityField);
  if (!isImmutable) return;

  const { entityName, tableName, identityField } = meta;

  ctx.it(`PATCH /api/${tableName}/:id - cannot modify ${identityField}`, async () => {
    const auth = await ctx.authHeader('admin');
    
    // Create an entity
    const created = await ctx.factory.create(entityName);
    const originalValue = created[identityField];

    // Attempt to modify the immutable field
    const response = await ctx.request
      .patch(`/api/${tableName}/${created.id}`)
      .set(auth)
      .send({ [identityField]: 'MODIFIED-9999-9999' });

    // Should either reject (400) or ignore the field (200 with unchanged value)
    if (response.status === 200) {
      const data = response.body.data || response.body;
      ctx.expect(data[identityField]).toBe(originalValue);
    } else {
      ctx.expect(response.status).toBe(400);
    }
  });
}

module.exports = {
  createGeneratesAutoIdentifier,
  sequentialCreationIncrements,
  clientCannotOverrideIdentifier,
  identifierIsImmutable,
};
