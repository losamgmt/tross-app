/**
 * Computed Field Test Scenarios
 *
 * Pure functions testing auto-generated identifiers and computed fields.
 * These verify that entities with computed fields generate them correctly.
 *
 * PRINCIPLE: Computed fields (like work_order_number, invoice_number) should
 * be auto-generated on creation, not manually provided by the client.
 */

/**
 * Check if entity has computed fields that are auto-generated
 */
function hasComputedFields(meta) {
  const { computedFields } = meta;
  return computedFields && Object.keys(computedFields).length > 0;
}

/**
 * Get auto-generated fields for an entity
 */
function getAutoGeneratedFields(meta) {
  if (!meta.computedFields) return [];
  
  return Object.entries(meta.computedFields)
    .filter(([_, config]) => config.type === 'auto_increment' || config.type === 'sequence')
    .map(([fieldName]) => fieldName);
}

/**
 * Get formatted fields (e.g., WO-001, INV-001)
 */
function getFormattedFields(meta) {
  if (!meta.computedFields) return [];
  
  return Object.entries(meta.computedFields)
    .filter(([_, config]) => config.format)
    .map(([fieldName, config]) => ({ fieldName, format: config.format }));
}

/**
 * Scenario: Create generates auto-incremented identifier
 *
 * Preconditions: Entity has computedFields with auto_increment type
 * Tests: Created entity has properly formatted identifier
 */
function createGeneratesAutoIncrementedId(meta, ctx) {
  const autoFields = getAutoGeneratedFields(meta);
  if (autoFields.length === 0) return;

  const { entityName, tableName } = meta;

  autoFields.forEach(fieldName => {
    ctx.it(`POST /api/${tableName} - generates ${fieldName} automatically`, async () => {
      const adminAuth = await ctx.authHeader('admin');
      const payload = ctx.factory.getValidPayload(entityName);
      
      // Explicitly DO NOT include the computed field
      delete payload[fieldName];

      const response = await ctx.request
        .post(`/api/${tableName}`)
        .set(adminAuth)
        .send(payload);

      ctx.expect(response.status).toBe(201);
      
      // The computed field should be present and non-null
      ctx.expect(response.body[fieldName]).toBeDefined();
      ctx.expect(response.body[fieldName]).not.toBeNull();
    });
  });
}

/**
 * Scenario: Computed field follows format pattern
 *
 * Preconditions: Entity has computedFields with format configuration
 * Tests: Generated value matches expected format
 */
function computedFieldFollowsFormat(meta, ctx) {
  const formattedFields = getFormattedFields(meta);
  if (formattedFields.length === 0) return;

  const { entityName, tableName } = meta;

  formattedFields.forEach(({ fieldName, format }) => {
    ctx.it(`POST /api/${tableName} - ${fieldName} follows format pattern`, async () => {
      const adminAuth = await ctx.authHeader('admin');
      const payload = ctx.factory.getValidPayload(entityName);
      delete payload[fieldName];

      const response = await ctx.request
        .post(`/api/${tableName}`)
        .set(adminAuth)
        .send(payload);

      ctx.expect(response.status).toBe(201);

      const value = response.body[fieldName];
      
      // Build regex from format - e.g., "WO-{number}" -> /^WO-\d+$/
      const regexPattern = format
        .replace('{number}', '\\d+')
        .replace('{date}', '\\d{8}')
        .replace('{year}', '\\d{4}');
      
      const regex = new RegExp(`^${regexPattern}$`);
      ctx.expect(value).toMatch(regex);
    });
  });
}

/**
 * Scenario: Sequential creation increments identifier
 *
 * Preconditions: Entity has auto_increment computed fields
 * Tests: Creating two entities produces sequential identifiers
 */
function sequentialCreationIncrements(meta, ctx) {
  const autoFields = getAutoGeneratedFields(meta);
  if (autoFields.length === 0) return;

  const { entityName, tableName } = meta;

  autoFields.forEach(fieldName => {
    ctx.it(`POST /api/${tableName} - sequential creates increment ${fieldName}`, async () => {
      const adminAuth = await ctx.authHeader('admin');

      // Create first entity
      const payload1 = ctx.factory.getValidPayload(entityName);
      delete payload1[fieldName];
      const response1 = await ctx.request
        .post(`/api/${tableName}`)
        .set(adminAuth)
        .send(payload1);

      ctx.expect(response1.status).toBe(201);
      const value1 = response1.body[fieldName];

      // Create second entity
      const payload2 = ctx.factory.getValidPayload(entityName);
      delete payload2[fieldName];
      const response2 = await ctx.request
        .post(`/api/${tableName}`)
        .set(adminAuth)
        .send(payload2);

      ctx.expect(response2.status).toBe(201);
      const value2 = response2.body[fieldName];

      // Values should be different
      ctx.expect(value2).not.toBe(value1);

      // Extract numeric portion and verify increment
      const num1 = parseInt(value1.replace(/\D/g, ''), 10);
      const num2 = parseInt(value2.replace(/\D/g, ''), 10);
      ctx.expect(num2).toBeGreaterThan(num1);
    });
  });
}

/**
 * Scenario: Client cannot override computed field
 *
 * Preconditions: Entity has computed fields
 * Tests: Providing computed field in payload is ignored or rejected
 */
function clientCannotOverrideComputedField(meta, ctx) {
  const autoFields = getAutoGeneratedFields(meta);
  if (autoFields.length === 0) return;

  const { entityName, tableName } = meta;

  autoFields.forEach(fieldName => {
    ctx.it(`POST /api/${tableName} - ignores client-provided ${fieldName}`, async () => {
      const adminAuth = await ctx.authHeader('admin');
      const payload = ctx.factory.getValidPayload(entityName);
      
      // Try to override with a specific value
      payload[fieldName] = 'HACKED-999';

      const response = await ctx.request
        .post(`/api/${tableName}`)
        .set(adminAuth)
        .send(payload);

      // Should succeed (field is ignored) or reject (400)
      if (response.status === 201) {
        // Server ignored the client value and generated its own
        ctx.expect(response.body[fieldName]).not.toBe('HACKED-999');
      } else {
        // Server rejected the attempt to override
        ctx.expect(response.status).toBe(400);
      }
    });
  });
}

module.exports = {
  createGeneratesAutoIncrementedId,
  computedFieldFollowsFormat,
  sequentialCreationIncrements,
  clientCannotOverrideComputedField,
};
